![img](img/Database.jpg)

# [Database] Transaction 정리

### REFERENCE

- [해시넷 - 트랜잭션](http://wiki.hash.kr/index.php/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
- [데이터베이스-로킹Locking-기법과-로킹-단위](https://raisonde.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%A1%9C%ED%82%B9Locking-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EB%A1%9C%ED%82%B9-%EB%8B%A8%EC%9C%84)
- [IT 위키 - 데이터베이스 로킹](https://itwiki.kr/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EB%A1%9C%ED%82%B9)
- [교착상태](https://osy0907.tistory.com/93)

## 💡 트랜잭션이란 무엇이고 어떤 특성을 가지는가?

### 트랜잭션이란?

트랜잭션은 데이터베이스의 상태를 변환시키는 `쪼갤 수 없는 업무 처리의 최소 단위`를 말합니다.

트랜잭션이란 개념은 작업의 완전성(integrity)을 보장해주는데, 일련의 논리적인 작업들을 모두 완벽하게 처리하거나 그렇지 못할 경우에는 작업 이전의 상태로 복구하여 오류(일부 쿼리만 수행된 상태)를 만들어 내지 않도록 해주는 기능입니다.

예를 들어, A라는 사람이 B라는 사람에게 1,000원을 지급하고 B가 그 돈을 받은 경우, 이 거래 기록은 더 이상 작게 쪼갤 수가 없는 하나의 트랜잭션을 구성합니다. 만약 A는 돈을 지불했으나 B는 돈을 받지 못했다면 그 거래는 성립되지 않아야 합니다. 이처럼 A가 돈을 지불하는 행위와 B가 돈을 받는 행위는 별개로 분리될 수 없으며 하나의 거래내역으로 처리되어야 하는 단일 거래입니다. 이런 거래의 최소 단위를 `트랜잭션`이라고 합니다. 트랜잭션 처리가 정상적으로 완료된 경우 `커밋(commit)`을 하고, 오류가 발생할 경우 원래 상태대로 `롤백(rollback)`을 합니다.

### 트랜잭션의 조건

트랜잭션이 안전하게 수행되기 위해서는 ACID 조건을 충족해야합니다. ACID란

- Atomicity(원자성) : 하나의 트랜잭션이 더 이상 작게 쪼갤 수 없는 최소한의 업무 단위입니다.
- Consistency(일관성) : 트랜잭션이 완료된 결과값이 일관적인 DB 상태를 유지해야합니다.
- Isolation(고립성) : 하나의 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장해야 합니다.
- Durability(지속성) : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업 결과가 저장되어야 합니다.

의 약자로서, 데이터베이스의 트랜잭션이 안전하게 수행되기 위한 4가지 필수적인 성질을 말합니다.

### 트랜잭션의 특징

트랜잭션 기능의 대표적인 이점 중 하나는 무정지성의 향상입니다. 운영체제 장애와 같은 서버 장애가 발생하여 그로부터 데이터베이스를 재가동한 때에 `장애 직전까지의 커밋결과를 손실하지않고 마치는 것`이 가능합니다. 트랜잭션을 지원하지 않는 데이터베이스의 경우 OS 장애나 프로세스의 비상적 종료에도 데이터가 손상될 수 있습니다.

## 💡 잠금기법(Locking)에 대해 설명하시오.

로킹 기법이란 하나의 트랜잭션이 데이터를 액세스하는 동안 다른 트랜잭션이 그데이터 항목을 액세스할 수 없도록 하는 병행 제어 기법을 말합니다. 잠금 기법에서 데이터베이스에서의 로킹(Locking) 단위란 말 그대로 "잠그는 단위"를 말 합니다. 즉, 한번에 한명만 사용할 수 있게 하는 단위를 `로킹 단위`, 사용하는 데이터 객체를`로크`라고 합니다.

| 로킹 단위 | 로크의 수 | 병행 제어 | 로킹 오버헤드 | 병행성 수준 |
| --------- | --------- | --------- | ------------- | ----------- |
| 커짐      | 적어짐    | 단순해짐  | 감소          | 낮아짐      |
| 작아짐    | 많아짐    | 복잡해짐  | 증가          | 높아짐      |

잠금은 `동시성 제어`를 위한 기능이고, 트랜잭션은 `데이터의 정합성`을 보장하기 위한 기능입니다. 트랜잭션의 조건 중, 고립성을 보장하게 하는 것이 이 로킹기법입니다. `데이터의 정합성`을 위해 `동시성 제어`를 한다라고 이해할 수 있습니다.

잠금 기법에서 트랜잭션들은 어떤 데이터를 접근하기 전에 잠금을 요청하여 잠금을 허락받아야 하며, 데이터를 갱신할 때는 반드시 잠금(Lock) -> 실행(Execute) -> 해제(Unlock)의 규칙을 따라야 합니다.

## 💡 잠금 기법의 문제점에 대해서 말하시오.

잠금기법을 사용해서 발생할 수 있는 문제에는 `블로킹(Blocking)`과 `교착상태(Deadlock)`가 있습니다.

### 블로킹(Blocking)

블로킹은 로킹으로 인해 특정 세션이 작업을 진행하지 못하는 상태를 말합니다. 로킹 중인 트랜잭션이 commit 또는 rollback 됨으로써 해제될 수 있습니다.

잦은 블로킹으로 인한 호율 하락을 막기 위해서는 트랜잭션을 최대한 짧게 설계해야 합니다.

### 교착상태(Deadlock)

![](https://images.velog.io/images/mulgyeol/post/f02da074-5bcc-45b6-88a4-4af7229ff866/image.png)
교착 상태란 어떤 한 트랜잭션이 사용하기 위해 잠가 놓은 자원을 사용하기 위해 기다리므로 모든 트랜잭션들이 실행을 전혀 진전시키지 못하고 무한정 기다리고 있는 상태를 말합니다.

## 💡 교착상태의 빈도를 낮추는 방법에는 무엇이 있나요?

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근합니다.
  - 위에서 트랜잭션 1 이 테이블 B -> A 의 순으로 접근했고, 트랜잭션 2 는 테이블 A -> B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다, 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.
